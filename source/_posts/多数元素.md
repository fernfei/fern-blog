---
title: 多数元素
date: 2022-08-08 22:30:50
tags:
- 位运算
- Leetcode
---

### 1.题目

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

提示：

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

### 2.思路

- 摩尔投票法

> 引用论文 https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf

> 算法演示 https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html

摩尔投票法(Boyer–Moore majority vote algorithm)出自论文，算法解决的问题是如何在任意多的候选人（选票无序），选出获得票数最多的那个。常见的算法是扫描一遍选票，对每个候选人进行统计的选票进行统计。当候选人的数目固定时，这个常见算法的时间复杂度为：O ( n ) O(n)O(n)，当候选人的数目不定时，统计选票可能会执行较长时间，可能需运行O ( n 2 ) O(n^2)O(n 2)的时间。当选票有序时，可以很容易编出O ( n ) O(n)O(n)的程序，首先找到中位数，然后检查中位数的个数是否超过选票的一半。这篇论文针对无序且侯选人不定的情形，提出了摩尔投票算法。算法的比较次数最多是选票（记为n）的两倍，可以在O ( n ) O(n)O(n)时间内选出获票最多的，空间开销为O ( 1 ) O(1)O(1)。

想象着这样一个画面：会议大厅站满了投票代表，每个都有一个牌子上面写着自己所选的候选人的名字。然后选举意见不合的（所选的候选人不同）两个人，会打一架，并且会同时击倒对方。显而易见，如果一个人拥有的选票比其它所有人加起来的选票还要多的话，这个候选人将会赢得这场“战争”，当混乱结束，最后剩下的那个代表（可能会有多个）将会来自多数人所站的阵营。但是如果所有参加候选人的选票都不是大多数（选票都未超过一半），那么最后站在那的代表（一个人）并不能代表所有的选票的大多数。因此，当某人站到最后时，需要统计他所选的候选人的选票是否超过一半（包括倒下的），来判断选票结果是否有效。

选票时每次遇到相同+1 反之-1票数归0时换下一个，到最后多数元素一定会把其他元素全部消掉然后剩出一个，因为多数元素总是是总数的两倍+1所以会把其他的票数全部消掉剩出一个，注：这里的题目给出的限定条件就是给定的数组总是多数数组，也就是票数总是总数的两倍+1

### 3.代码

```java
public int majorityElement(int[] nums) {
        int count = 0;
        int majority = 0;
        for (int num : nums) {
            if (count == 0) {
                majority = num;
            }
            count += (num == majority) ? 1 : -1;
        }
        return majority;
    }
```

