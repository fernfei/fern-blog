---
title: 二进制手表
date: 2022-08-22 00:53:40
tags:
- 位运算
- LeetCode
---

### 1.题目

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

- 例如，下面的二进制手表读取 `"3:25"` 。

![img](http://image.hi-hufei.com/typora/binary_clock_samui_moon.jpg)

给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

- 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。

  分钟必须由两位数组成，可能会以零开头：

- 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。



**示例 1：**

``` 
输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
```

**示例 2：**

``` 
输入：turnedOn = 9
输出：[]
```

### 2.思路

#### 2.1二进制枚举

用二进制的高4位表示时 低6位表示为 `1111 111111` 十进制表示为1023，`1111 111111>>6=1111`右移得出高4位二进制

`1111 111111 & 111111 = 111111 `   得出低6位 1111，高4位的最大数用十进制表示为15 低6位最大数用十进制表示为63很显然不满足时分禁止因此需要判断 hour<12 minutes<60

#### 2.2时分枚举

穷举出 12小时与60分钟所有数字的组合，再判断hour && minutes的比特位1的个数是否超过turnOn，举例说明：

3的二进制为 11可以看作为 10+1 = 11 即 2+1=3根据上述可以得出我们只需要判断时分的二进制数位1的个数即可判断出此时的组合是否满足入参turneOn

### 3.实现

#### 3.1二进制枚举

``` java
public List<String> readBinaryWatch2(int turnOn) {
        // 高4位表示  低6位表示分制
        // 0001 000000
        // 0010 000000
        // 0100 000000
        // 1000 000000
        // 0000 100000
        // 0000 010000
        // 0000 001000
        // 0000 000100
        // 0000 000010
        // 0000 000001
        List<String> ans = new LinkedList();
        for (int i = 0; i < 1024; i++) {
            int h = i >> 6, m = i & 63;
            if (h < 12 && m < 60 && (Integer.bitCount(i) == turnOn)) {
                ans.add(h + ":" + (m < 10 ? "0" + m : m));
            }
        }
        return ans;
    }
```

#### 3.2时分枚举

``` java
    public List<String> readBinaryWatch2(int turnedOn) {
        List<String> ans=new LinkedList();
        // 1 2 4 8 hour 0-11
        // 1 2 4 8 16 32 minutes 0-59
        for(int i =0;i<12;++i){
            for(int j=0;j<60;++j){
                if(Integer.bitCount(i)+Integer.bitCount(j)==turnedOn){
                    ans.add(i + ":" + (j < 10 ? "0" + j : j));
                }
            }
        }
        return ans;
    }
```

上述算法的时间空间都是O(1)因为所耗时与内存占用都是常量
